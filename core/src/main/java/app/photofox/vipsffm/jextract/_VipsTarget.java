// Generated by jextract

package app.photofox.vipsffm.jextract;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _VipsTarget {
 *     VipsConnection parent_object;
 *     gboolean memory;
 *     gboolean ended;
 *     GString *memory_buffer;
 *     VipsBlob *blob;
 *     unsigned char output_buffer[8500];
 *     int write_point;
 *     gint64 position;
 *     gboolean delete_on_close;
 *     char *delete_on_close_filename;
 * }
 * }
 */
public class _VipsTarget {

    _VipsTarget() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _VipsConnection.layout().withName("parent_object"),
        VipsRaw.C_INT.withName("memory"),
        VipsRaw.C_INT.withName("ended"),
        VipsRaw.C_POINTER.withName("memory_buffer"),
        VipsRaw.C_POINTER.withName("blob"),
        MemoryLayout.sequenceLayout(8500, VipsRaw.C_CHAR).withName("output_buffer"),
        VipsRaw.C_INT.withName("write_point"),
        VipsRaw.C_LONG_LONG.withName("position"),
        VipsRaw.C_INT.withName("delete_on_close"),
        MemoryLayout.paddingLayout(4),
        VipsRaw.C_POINTER.withName("delete_on_close_filename")
    ).withName("_VipsTarget");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout parent_object$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("parent_object"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VipsConnection parent_object
     * }
     */
    public static final GroupLayout parent_object$layout() {
        return parent_object$LAYOUT;
    }

    private static final long parent_object$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VipsConnection parent_object
     * }
     */
    public static final long parent_object$offset() {
        return parent_object$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VipsConnection parent_object
     * }
     */
    public static MemorySegment parent_object(MemorySegment struct) {
        return struct.asSlice(parent_object$OFFSET, parent_object$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VipsConnection parent_object
     * }
     */
    public static void parent_object(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, parent_object$OFFSET, parent_object$LAYOUT.byteSize());
    }

    private static final OfInt memory$LAYOUT = (OfInt)$LAYOUT.select(groupElement("memory"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean memory
     * }
     */
    public static final OfInt memory$layout() {
        return memory$LAYOUT;
    }

    private static final long memory$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean memory
     * }
     */
    public static final long memory$offset() {
        return memory$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean memory
     * }
     */
    public static int memory(MemorySegment struct) {
        return struct.get(memory$LAYOUT, memory$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean memory
     * }
     */
    public static void memory(MemorySegment struct, int fieldValue) {
        struct.set(memory$LAYOUT, memory$OFFSET, fieldValue);
    }

    private static final OfInt ended$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ended"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean ended
     * }
     */
    public static final OfInt ended$layout() {
        return ended$LAYOUT;
    }

    private static final long ended$OFFSET = 108;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean ended
     * }
     */
    public static final long ended$offset() {
        return ended$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean ended
     * }
     */
    public static int ended(MemorySegment struct) {
        return struct.get(ended$LAYOUT, ended$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean ended
     * }
     */
    public static void ended(MemorySegment struct, int fieldValue) {
        struct.set(ended$LAYOUT, ended$OFFSET, fieldValue);
    }

    private static final AddressLayout memory_buffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("memory_buffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GString *memory_buffer
     * }
     */
    public static final AddressLayout memory_buffer$layout() {
        return memory_buffer$LAYOUT;
    }

    private static final long memory_buffer$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GString *memory_buffer
     * }
     */
    public static final long memory_buffer$offset() {
        return memory_buffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GString *memory_buffer
     * }
     */
    public static MemorySegment memory_buffer(MemorySegment struct) {
        return struct.get(memory_buffer$LAYOUT, memory_buffer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GString *memory_buffer
     * }
     */
    public static void memory_buffer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(memory_buffer$LAYOUT, memory_buffer$OFFSET, fieldValue);
    }

    private static final AddressLayout blob$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("blob"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VipsBlob *blob
     * }
     */
    public static final AddressLayout blob$layout() {
        return blob$LAYOUT;
    }

    private static final long blob$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VipsBlob *blob
     * }
     */
    public static final long blob$offset() {
        return blob$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VipsBlob *blob
     * }
     */
    public static MemorySegment blob(MemorySegment struct) {
        return struct.get(blob$LAYOUT, blob$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VipsBlob *blob
     * }
     */
    public static void blob(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(blob$LAYOUT, blob$OFFSET, fieldValue);
    }

    private static final SequenceLayout output_buffer$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("output_buffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned char output_buffer[8500]
     * }
     */
    public static final SequenceLayout output_buffer$layout() {
        return output_buffer$LAYOUT;
    }

    private static final long output_buffer$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned char output_buffer[8500]
     * }
     */
    public static final long output_buffer$offset() {
        return output_buffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned char output_buffer[8500]
     * }
     */
    public static MemorySegment output_buffer(MemorySegment struct) {
        return struct.asSlice(output_buffer$OFFSET, output_buffer$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned char output_buffer[8500]
     * }
     */
    public static void output_buffer(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, output_buffer$OFFSET, output_buffer$LAYOUT.byteSize());
    }

    private static long[] output_buffer$DIMS = { 8500 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * unsigned char output_buffer[8500]
     * }
     */
    public static long[] output_buffer$dimensions() {
        return output_buffer$DIMS;
    }
    private static final VarHandle output_buffer$ELEM_HANDLE = output_buffer$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * unsigned char output_buffer[8500]
     * }
     */
    public static byte output_buffer(MemorySegment struct, long index0) {
        return (byte)output_buffer$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * unsigned char output_buffer[8500]
     * }
     */
    public static void output_buffer(MemorySegment struct, long index0, byte fieldValue) {
        output_buffer$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfInt write_point$LAYOUT = (OfInt)$LAYOUT.select(groupElement("write_point"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int write_point
     * }
     */
    public static final OfInt write_point$layout() {
        return write_point$LAYOUT;
    }

    private static final long write_point$OFFSET = 8628;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int write_point
     * }
     */
    public static final long write_point$offset() {
        return write_point$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int write_point
     * }
     */
    public static int write_point(MemorySegment struct) {
        return struct.get(write_point$LAYOUT, write_point$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int write_point
     * }
     */
    public static void write_point(MemorySegment struct, int fieldValue) {
        struct.set(write_point$LAYOUT, write_point$OFFSET, fieldValue);
    }

    private static final OfLong position$LAYOUT = (OfLong)$LAYOUT.select(groupElement("position"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gint64 position
     * }
     */
    public static final OfLong position$layout() {
        return position$LAYOUT;
    }

    private static final long position$OFFSET = 8632;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gint64 position
     * }
     */
    public static final long position$offset() {
        return position$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gint64 position
     * }
     */
    public static long position(MemorySegment struct) {
        return struct.get(position$LAYOUT, position$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gint64 position
     * }
     */
    public static void position(MemorySegment struct, long fieldValue) {
        struct.set(position$LAYOUT, position$OFFSET, fieldValue);
    }

    private static final OfInt delete_on_close$LAYOUT = (OfInt)$LAYOUT.select(groupElement("delete_on_close"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean delete_on_close
     * }
     */
    public static final OfInt delete_on_close$layout() {
        return delete_on_close$LAYOUT;
    }

    private static final long delete_on_close$OFFSET = 8640;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean delete_on_close
     * }
     */
    public static final long delete_on_close$offset() {
        return delete_on_close$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean delete_on_close
     * }
     */
    public static int delete_on_close(MemorySegment struct) {
        return struct.get(delete_on_close$LAYOUT, delete_on_close$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean delete_on_close
     * }
     */
    public static void delete_on_close(MemorySegment struct, int fieldValue) {
        struct.set(delete_on_close$LAYOUT, delete_on_close$OFFSET, fieldValue);
    }

    private static final AddressLayout delete_on_close_filename$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("delete_on_close_filename"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *delete_on_close_filename
     * }
     */
    public static final AddressLayout delete_on_close_filename$layout() {
        return delete_on_close_filename$LAYOUT;
    }

    private static final long delete_on_close_filename$OFFSET = 8648;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *delete_on_close_filename
     * }
     */
    public static final long delete_on_close_filename$offset() {
        return delete_on_close_filename$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *delete_on_close_filename
     * }
     */
    public static MemorySegment delete_on_close_filename(MemorySegment struct) {
        return struct.get(delete_on_close_filename$LAYOUT, delete_on_close_filename$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *delete_on_close_filename
     * }
     */
    public static void delete_on_close_filename(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(delete_on_close_filename$LAYOUT, delete_on_close_filename$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

