// Generated by jextract

package app.photofox.vipsffm.jextract;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _VipsObjectClass {
 *     GObjectClass parent_class;
 *     int (*build)(VipsObject *);
 *     int (*postbuild)(VipsObject *, void *);
 *     void (*summary_class)(struct _VipsObjectClass *, VipsBuf *);
 *     void (*summary)(VipsObject *, VipsBuf *);
 *     void (*dump)(VipsObject *, VipsBuf *);
 *     void (*sanity)(VipsObject *, VipsBuf *);
 *     void (*rewind)(VipsObject *);
 *     void (*preclose)(VipsObject *);
 *     void (*close)(VipsObject *);
 *     void (*postclose)(VipsObject *);
 *     VipsObject *(*new_from_string)(const char *);
 *     void (*to_string)(VipsObject *, VipsBuf *);
 *     gboolean output_needs_arg;
 *     int (*output_to_arg)(VipsObject *, const char *);
 *     const char *nickname;
 *     const char *description;
 *     VipsArgumentTable *argument_table;
 *     GSList *argument_table_traverse;
 *     GType argument_table_traverse_gtype;
 *     gboolean deprecated;
 *     void (*_vips_reserved1)(void);
 *     void (*_vips_reserved2)(void);
 *     void (*_vips_reserved3)(void);
 *     void (*_vips_reserved4)(void);
 * }
 * }
 */
public class _VipsObjectClass {

    _VipsObjectClass() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        _GObjectClass.layout().withName("parent_class"),
        VipsRaw.C_POINTER.withName("build"),
        VipsRaw.C_POINTER.withName("postbuild"),
        VipsRaw.C_POINTER.withName("summary_class"),
        VipsRaw.C_POINTER.withName("summary"),
        VipsRaw.C_POINTER.withName("dump"),
        VipsRaw.C_POINTER.withName("sanity"),
        VipsRaw.C_POINTER.withName("rewind"),
        VipsRaw.C_POINTER.withName("preclose"),
        VipsRaw.C_POINTER.withName("close"),
        VipsRaw.C_POINTER.withName("postclose"),
        VipsRaw.C_POINTER.withName("new_from_string"),
        VipsRaw.C_POINTER.withName("to_string"),
        VipsRaw.C_INT.withName("output_needs_arg"),
        MemoryLayout.paddingLayout(4),
        VipsRaw.C_POINTER.withName("output_to_arg"),
        VipsRaw.C_POINTER.withName("nickname"),
        VipsRaw.C_POINTER.withName("description"),
        VipsRaw.C_POINTER.withName("argument_table"),
        VipsRaw.C_POINTER.withName("argument_table_traverse"),
        VipsRaw.C_LONG.withName("argument_table_traverse_gtype"),
        VipsRaw.C_INT.withName("deprecated"),
        MemoryLayout.paddingLayout(4),
        VipsRaw.C_POINTER.withName("_vips_reserved1"),
        VipsRaw.C_POINTER.withName("_vips_reserved2"),
        VipsRaw.C_POINTER.withName("_vips_reserved3"),
        VipsRaw.C_POINTER.withName("_vips_reserved4")
    ).withName("_VipsObjectClass");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout parent_class$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("parent_class"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GObjectClass parent_class
     * }
     */
    public static final GroupLayout parent_class$layout() {
        return parent_class$LAYOUT;
    }

    private static final long parent_class$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GObjectClass parent_class
     * }
     */
    public static final long parent_class$offset() {
        return parent_class$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GObjectClass parent_class
     * }
     */
    public static MemorySegment parent_class(MemorySegment struct) {
        return struct.asSlice(parent_class$OFFSET, parent_class$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GObjectClass parent_class
     * }
     */
    public static void parent_class(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, parent_class$OFFSET, parent_class$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * int (*build)(VipsObject *)
     * }
     */
    public static class build {

        build() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            VipsRaw.C_INT,
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(build.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(build.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout build$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("build"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*build)(VipsObject *)
     * }
     */
    public static final AddressLayout build$layout() {
        return build$LAYOUT;
    }

    private static final long build$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*build)(VipsObject *)
     * }
     */
    public static final long build$offset() {
        return build$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*build)(VipsObject *)
     * }
     */
    public static MemorySegment build(MemorySegment struct) {
        return struct.get(build$LAYOUT, build$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*build)(VipsObject *)
     * }
     */
    public static void build(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(build$LAYOUT, build$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*postbuild)(VipsObject *, void *)
     * }
     */
    public static class postbuild {

        postbuild() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            VipsRaw.C_INT,
            VipsRaw.C_POINTER,
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(postbuild.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(postbuild.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout postbuild$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("postbuild"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*postbuild)(VipsObject *, void *)
     * }
     */
    public static final AddressLayout postbuild$layout() {
        return postbuild$LAYOUT;
    }

    private static final long postbuild$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*postbuild)(VipsObject *, void *)
     * }
     */
    public static final long postbuild$offset() {
        return postbuild$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*postbuild)(VipsObject *, void *)
     * }
     */
    public static MemorySegment postbuild(MemorySegment struct) {
        return struct.get(postbuild$LAYOUT, postbuild$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*postbuild)(VipsObject *, void *)
     * }
     */
    public static void postbuild(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(postbuild$LAYOUT, postbuild$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*summary_class)(struct _VipsObjectClass *, VipsBuf *)
     * }
     */
    public static class summary_class {

        summary_class() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            VipsRaw.C_POINTER,
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(summary_class.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(summary_class.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout summary_class$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("summary_class"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*summary_class)(struct _VipsObjectClass *, VipsBuf *)
     * }
     */
    public static final AddressLayout summary_class$layout() {
        return summary_class$LAYOUT;
    }

    private static final long summary_class$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*summary_class)(struct _VipsObjectClass *, VipsBuf *)
     * }
     */
    public static final long summary_class$offset() {
        return summary_class$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*summary_class)(struct _VipsObjectClass *, VipsBuf *)
     * }
     */
    public static MemorySegment summary_class(MemorySegment struct) {
        return struct.get(summary_class$LAYOUT, summary_class$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*summary_class)(struct _VipsObjectClass *, VipsBuf *)
     * }
     */
    public static void summary_class(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(summary_class$LAYOUT, summary_class$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*summary)(VipsObject *, VipsBuf *)
     * }
     */
    public static class summary {

        summary() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            VipsRaw.C_POINTER,
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(summary.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(summary.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout summary$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("summary"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*summary)(VipsObject *, VipsBuf *)
     * }
     */
    public static final AddressLayout summary$layout() {
        return summary$LAYOUT;
    }

    private static final long summary$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*summary)(VipsObject *, VipsBuf *)
     * }
     */
    public static final long summary$offset() {
        return summary$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*summary)(VipsObject *, VipsBuf *)
     * }
     */
    public static MemorySegment summary(MemorySegment struct) {
        return struct.get(summary$LAYOUT, summary$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*summary)(VipsObject *, VipsBuf *)
     * }
     */
    public static void summary(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(summary$LAYOUT, summary$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*dump)(VipsObject *, VipsBuf *)
     * }
     */
    public static class dump {

        dump() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            VipsRaw.C_POINTER,
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(dump.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(dump.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout dump$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dump"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*dump)(VipsObject *, VipsBuf *)
     * }
     */
    public static final AddressLayout dump$layout() {
        return dump$LAYOUT;
    }

    private static final long dump$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*dump)(VipsObject *, VipsBuf *)
     * }
     */
    public static final long dump$offset() {
        return dump$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*dump)(VipsObject *, VipsBuf *)
     * }
     */
    public static MemorySegment dump(MemorySegment struct) {
        return struct.get(dump$LAYOUT, dump$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*dump)(VipsObject *, VipsBuf *)
     * }
     */
    public static void dump(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dump$LAYOUT, dump$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*sanity)(VipsObject *, VipsBuf *)
     * }
     */
    public static class sanity {

        sanity() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            VipsRaw.C_POINTER,
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(sanity.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sanity.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sanity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sanity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*sanity)(VipsObject *, VipsBuf *)
     * }
     */
    public static final AddressLayout sanity$layout() {
        return sanity$LAYOUT;
    }

    private static final long sanity$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*sanity)(VipsObject *, VipsBuf *)
     * }
     */
    public static final long sanity$offset() {
        return sanity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*sanity)(VipsObject *, VipsBuf *)
     * }
     */
    public static MemorySegment sanity(MemorySegment struct) {
        return struct.get(sanity$LAYOUT, sanity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*sanity)(VipsObject *, VipsBuf *)
     * }
     */
    public static void sanity(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sanity$LAYOUT, sanity$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*rewind)(VipsObject *)
     * }
     */
    public static class rewind {

        rewind() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(rewind.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(rewind.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout rewind$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("rewind"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*rewind)(VipsObject *)
     * }
     */
    public static final AddressLayout rewind$layout() {
        return rewind$LAYOUT;
    }

    private static final long rewind$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*rewind)(VipsObject *)
     * }
     */
    public static final long rewind$offset() {
        return rewind$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*rewind)(VipsObject *)
     * }
     */
    public static MemorySegment rewind(MemorySegment struct) {
        return struct.get(rewind$LAYOUT, rewind$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*rewind)(VipsObject *)
     * }
     */
    public static void rewind(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(rewind$LAYOUT, rewind$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*preclose)(VipsObject *)
     * }
     */
    public static class preclose {

        preclose() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(preclose.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(preclose.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout preclose$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("preclose"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*preclose)(VipsObject *)
     * }
     */
    public static final AddressLayout preclose$layout() {
        return preclose$LAYOUT;
    }

    private static final long preclose$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*preclose)(VipsObject *)
     * }
     */
    public static final long preclose$offset() {
        return preclose$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*preclose)(VipsObject *)
     * }
     */
    public static MemorySegment preclose(MemorySegment struct) {
        return struct.get(preclose$LAYOUT, preclose$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*preclose)(VipsObject *)
     * }
     */
    public static void preclose(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(preclose$LAYOUT, preclose$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*close)(VipsObject *)
     * }
     */
    public static class close {

        close() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(close.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(close.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout close$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("close"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*close)(VipsObject *)
     * }
     */
    public static final AddressLayout close$layout() {
        return close$LAYOUT;
    }

    private static final long close$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*close)(VipsObject *)
     * }
     */
    public static final long close$offset() {
        return close$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*close)(VipsObject *)
     * }
     */
    public static MemorySegment close(MemorySegment struct) {
        return struct.get(close$LAYOUT, close$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*close)(VipsObject *)
     * }
     */
    public static void close(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(close$LAYOUT, close$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*postclose)(VipsObject *)
     * }
     */
    public static class postclose {

        postclose() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(postclose.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(postclose.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout postclose$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("postclose"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*postclose)(VipsObject *)
     * }
     */
    public static final AddressLayout postclose$layout() {
        return postclose$LAYOUT;
    }

    private static final long postclose$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*postclose)(VipsObject *)
     * }
     */
    public static final long postclose$offset() {
        return postclose$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*postclose)(VipsObject *)
     * }
     */
    public static MemorySegment postclose(MemorySegment struct) {
        return struct.get(postclose$LAYOUT, postclose$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*postclose)(VipsObject *)
     * }
     */
    public static void postclose(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(postclose$LAYOUT, postclose$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * VipsObject *(*new_from_string)(const char *)
     * }
     */
    public static class new_from_string {

        new_from_string() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            VipsRaw.C_POINTER,
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(new_from_string.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(new_from_string.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout new_from_string$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("new_from_string"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VipsObject *(*new_from_string)(const char *)
     * }
     */
    public static final AddressLayout new_from_string$layout() {
        return new_from_string$LAYOUT;
    }

    private static final long new_from_string$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VipsObject *(*new_from_string)(const char *)
     * }
     */
    public static final long new_from_string$offset() {
        return new_from_string$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VipsObject *(*new_from_string)(const char *)
     * }
     */
    public static MemorySegment new_from_string(MemorySegment struct) {
        return struct.get(new_from_string$LAYOUT, new_from_string$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VipsObject *(*new_from_string)(const char *)
     * }
     */
    public static void new_from_string(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(new_from_string$LAYOUT, new_from_string$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*to_string)(VipsObject *, VipsBuf *)
     * }
     */
    public static class to_string {

        to_string() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            VipsRaw.C_POINTER,
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(to_string.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(to_string.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout to_string$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("to_string"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*to_string)(VipsObject *, VipsBuf *)
     * }
     */
    public static final AddressLayout to_string$layout() {
        return to_string$LAYOUT;
    }

    private static final long to_string$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*to_string)(VipsObject *, VipsBuf *)
     * }
     */
    public static final long to_string$offset() {
        return to_string$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*to_string)(VipsObject *, VipsBuf *)
     * }
     */
    public static MemorySegment to_string(MemorySegment struct) {
        return struct.get(to_string$LAYOUT, to_string$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*to_string)(VipsObject *, VipsBuf *)
     * }
     */
    public static void to_string(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(to_string$LAYOUT, to_string$OFFSET, fieldValue);
    }

    private static final OfInt output_needs_arg$LAYOUT = (OfInt)$LAYOUT.select(groupElement("output_needs_arg"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean output_needs_arg
     * }
     */
    public static final OfInt output_needs_arg$layout() {
        return output_needs_arg$LAYOUT;
    }

    private static final long output_needs_arg$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean output_needs_arg
     * }
     */
    public static final long output_needs_arg$offset() {
        return output_needs_arg$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean output_needs_arg
     * }
     */
    public static int output_needs_arg(MemorySegment struct) {
        return struct.get(output_needs_arg$LAYOUT, output_needs_arg$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean output_needs_arg
     * }
     */
    public static void output_needs_arg(MemorySegment struct, int fieldValue) {
        struct.set(output_needs_arg$LAYOUT, output_needs_arg$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*output_to_arg)(VipsObject *, const char *)
     * }
     */
    public static class output_to_arg {

        output_to_arg() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            VipsRaw.C_INT,
            VipsRaw.C_POINTER,
            VipsRaw.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(output_to_arg.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(output_to_arg.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout output_to_arg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("output_to_arg"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*output_to_arg)(VipsObject *, const char *)
     * }
     */
    public static final AddressLayout output_to_arg$layout() {
        return output_to_arg$LAYOUT;
    }

    private static final long output_to_arg$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*output_to_arg)(VipsObject *, const char *)
     * }
     */
    public static final long output_to_arg$offset() {
        return output_to_arg$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*output_to_arg)(VipsObject *, const char *)
     * }
     */
    public static MemorySegment output_to_arg(MemorySegment struct) {
        return struct.get(output_to_arg$LAYOUT, output_to_arg$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*output_to_arg)(VipsObject *, const char *)
     * }
     */
    public static void output_to_arg(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(output_to_arg$LAYOUT, output_to_arg$OFFSET, fieldValue);
    }

    private static final AddressLayout nickname$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("nickname"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *nickname
     * }
     */
    public static final AddressLayout nickname$layout() {
        return nickname$LAYOUT;
    }

    private static final long nickname$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *nickname
     * }
     */
    public static final long nickname$offset() {
        return nickname$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *nickname
     * }
     */
    public static MemorySegment nickname(MemorySegment struct) {
        return struct.get(nickname$LAYOUT, nickname$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *nickname
     * }
     */
    public static void nickname(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(nickname$LAYOUT, nickname$OFFSET, fieldValue);
    }

    private static final AddressLayout description$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("description"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *description
     * }
     */
    public static final AddressLayout description$layout() {
        return description$LAYOUT;
    }

    private static final long description$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *description
     * }
     */
    public static final long description$offset() {
        return description$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *description
     * }
     */
    public static MemorySegment description(MemorySegment struct) {
        return struct.get(description$LAYOUT, description$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *description
     * }
     */
    public static void description(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(description$LAYOUT, description$OFFSET, fieldValue);
    }

    private static final AddressLayout argument_table$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("argument_table"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * VipsArgumentTable *argument_table
     * }
     */
    public static final AddressLayout argument_table$layout() {
        return argument_table$LAYOUT;
    }

    private static final long argument_table$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * VipsArgumentTable *argument_table
     * }
     */
    public static final long argument_table$offset() {
        return argument_table$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * VipsArgumentTable *argument_table
     * }
     */
    public static MemorySegment argument_table(MemorySegment struct) {
        return struct.get(argument_table$LAYOUT, argument_table$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * VipsArgumentTable *argument_table
     * }
     */
    public static void argument_table(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(argument_table$LAYOUT, argument_table$OFFSET, fieldValue);
    }

    private static final AddressLayout argument_table_traverse$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("argument_table_traverse"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GSList *argument_table_traverse
     * }
     */
    public static final AddressLayout argument_table_traverse$layout() {
        return argument_table_traverse$LAYOUT;
    }

    private static final long argument_table_traverse$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GSList *argument_table_traverse
     * }
     */
    public static final long argument_table_traverse$offset() {
        return argument_table_traverse$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GSList *argument_table_traverse
     * }
     */
    public static MemorySegment argument_table_traverse(MemorySegment struct) {
        return struct.get(argument_table_traverse$LAYOUT, argument_table_traverse$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GSList *argument_table_traverse
     * }
     */
    public static void argument_table_traverse(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(argument_table_traverse$LAYOUT, argument_table_traverse$OFFSET, fieldValue);
    }

    private static final OfLong argument_table_traverse_gtype$LAYOUT = (OfLong)$LAYOUT.select(groupElement("argument_table_traverse_gtype"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * GType argument_table_traverse_gtype
     * }
     */
    public static final OfLong argument_table_traverse_gtype$layout() {
        return argument_table_traverse_gtype$LAYOUT;
    }

    private static final long argument_table_traverse_gtype$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * GType argument_table_traverse_gtype
     * }
     */
    public static final long argument_table_traverse_gtype$offset() {
        return argument_table_traverse_gtype$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * GType argument_table_traverse_gtype
     * }
     */
    public static long argument_table_traverse_gtype(MemorySegment struct) {
        return struct.get(argument_table_traverse_gtype$LAYOUT, argument_table_traverse_gtype$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * GType argument_table_traverse_gtype
     * }
     */
    public static void argument_table_traverse_gtype(MemorySegment struct, long fieldValue) {
        struct.set(argument_table_traverse_gtype$LAYOUT, argument_table_traverse_gtype$OFFSET, fieldValue);
    }

    private static final OfInt deprecated$LAYOUT = (OfInt)$LAYOUT.select(groupElement("deprecated"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * gboolean deprecated
     * }
     */
    public static final OfInt deprecated$layout() {
        return deprecated$LAYOUT;
    }

    private static final long deprecated$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * gboolean deprecated
     * }
     */
    public static final long deprecated$offset() {
        return deprecated$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * gboolean deprecated
     * }
     */
    public static int deprecated(MemorySegment struct) {
        return struct.get(deprecated$LAYOUT, deprecated$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * gboolean deprecated
     * }
     */
    public static void deprecated(MemorySegment struct, int fieldValue) {
        struct.set(deprecated$LAYOUT, deprecated$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*_vips_reserved1)(void)
     * }
     */
    public static class _vips_reserved1 {

        _vips_reserved1() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(_vips_reserved1.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_vips_reserved1.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _vips_reserved1$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_vips_reserved1"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*_vips_reserved1)(void)
     * }
     */
    public static final AddressLayout _vips_reserved1$layout() {
        return _vips_reserved1$LAYOUT;
    }

    private static final long _vips_reserved1$OFFSET = 296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*_vips_reserved1)(void)
     * }
     */
    public static final long _vips_reserved1$offset() {
        return _vips_reserved1$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*_vips_reserved1)(void)
     * }
     */
    public static MemorySegment _vips_reserved1(MemorySegment struct) {
        return struct.get(_vips_reserved1$LAYOUT, _vips_reserved1$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*_vips_reserved1)(void)
     * }
     */
    public static void _vips_reserved1(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_vips_reserved1$LAYOUT, _vips_reserved1$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*_vips_reserved2)(void)
     * }
     */
    public static class _vips_reserved2 {

        _vips_reserved2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(_vips_reserved2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_vips_reserved2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _vips_reserved2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_vips_reserved2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*_vips_reserved2)(void)
     * }
     */
    public static final AddressLayout _vips_reserved2$layout() {
        return _vips_reserved2$LAYOUT;
    }

    private static final long _vips_reserved2$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*_vips_reserved2)(void)
     * }
     */
    public static final long _vips_reserved2$offset() {
        return _vips_reserved2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*_vips_reserved2)(void)
     * }
     */
    public static MemorySegment _vips_reserved2(MemorySegment struct) {
        return struct.get(_vips_reserved2$LAYOUT, _vips_reserved2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*_vips_reserved2)(void)
     * }
     */
    public static void _vips_reserved2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_vips_reserved2$LAYOUT, _vips_reserved2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*_vips_reserved3)(void)
     * }
     */
    public static class _vips_reserved3 {

        _vips_reserved3() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(_vips_reserved3.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_vips_reserved3.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _vips_reserved3$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_vips_reserved3"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*_vips_reserved3)(void)
     * }
     */
    public static final AddressLayout _vips_reserved3$layout() {
        return _vips_reserved3$LAYOUT;
    }

    private static final long _vips_reserved3$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*_vips_reserved3)(void)
     * }
     */
    public static final long _vips_reserved3$offset() {
        return _vips_reserved3$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*_vips_reserved3)(void)
     * }
     */
    public static MemorySegment _vips_reserved3(MemorySegment struct) {
        return struct.get(_vips_reserved3$LAYOUT, _vips_reserved3$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*_vips_reserved3)(void)
     * }
     */
    public static void _vips_reserved3(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_vips_reserved3$LAYOUT, _vips_reserved3$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*_vips_reserved4)(void)
     * }
     */
    public static class _vips_reserved4 {

        _vips_reserved4() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = VipsRaw.upcallHandle(_vips_reserved4.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_vips_reserved4.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _vips_reserved4$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_vips_reserved4"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*_vips_reserved4)(void)
     * }
     */
    public static final AddressLayout _vips_reserved4$layout() {
        return _vips_reserved4$LAYOUT;
    }

    private static final long _vips_reserved4$OFFSET = 320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*_vips_reserved4)(void)
     * }
     */
    public static final long _vips_reserved4$offset() {
        return _vips_reserved4$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*_vips_reserved4)(void)
     * }
     */
    public static MemorySegment _vips_reserved4(MemorySegment struct) {
        return struct.get(_vips_reserved4$LAYOUT, _vips_reserved4$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*_vips_reserved4)(void)
     * }
     */
    public static void _vips_reserved4(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_vips_reserved4$LAYOUT, _vips_reserved4$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

