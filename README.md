# vips-ffm

[libvips](https://github.com/libvips/libvips) bindings for JVM projects, using the "Foreign Function & Memory API"
([JEP 454](https://openjdk.org/jeps/454)), and the "Class-File API" ([JEP 457](https://openjdk.org/jeps/457)) released in JDK 22. The combination
of libvips, FFM, and auto-generated helpers makes for performant, safe, and ergonomic image manipulation in JVM systems.
Supports a vast range of image formats, including HEIC, JXL, WebP, PNG, JPEG, and more. Pronounced "vips (like zips)
eff-eff-emm".

Raw bindings are automatically generated using `jextract`, then processed and wrapped with some lightweight "helpers" to
allow for safe, idiomatic usage.

Like what you've read so far? Please give the repo a star 🌟️!

## Usage

This is still a work-in-progress, and there aren't any packages published yet. As the project uses the FFM API, it must
target JDK 22+.

The libvips API is exposed via a Java helper class, `Vips`. You must provide an [Arena][1] during initialisation. This
Arena constrains the lifetime of objects generated during usage of the vips-ffm API, so be careful to only keep it in
scope for as long as you need to. If the arena doesn't close, your memory usage will grow forever. Constructing the
`Vips` object is cheap, as it's just a wrapper, so make them as you need.

This library **does not** include `libvips` in the download, you must add it to the system you're building on, then make
sure it's available in `DYLD_LIBRARY_PATH` (on macOS) or `LD_LIBRARY_PATH` (on Linux). 

🚨 Raw bindings generated by `jextract` are available in `VipsRaw` as static methods. It's very difficult to use
`VipsRaw` functions without accidentally causing memory leaks, or even segfaults! If what you want to do is available in
`Vips`, use that instead. If you notice something missing, open a GitHub Issue.

### Thumbnail sample

To get a feeling for the bindings, here's an indicative sample written in Kotlin (using the Java bindings) that:
* Loads an original JPEG image from disk
* Writes a copy of it to disk
* Creates a 400px thumbnail from the original, and writes that to disk

```kotlin
import app.photofox.vipsffm.generated.Vips
import java.lang.foreign.Arena

// ...

Arena.ofConfined().use { arena ->
    val vips = Vips(arena)

    val version = vips.versionString()
    logger.info("vips version: $version")
  
    val sourceImage = vips.imageNewFromFile(
        "sample/src/main/resources/sample_images/rabbit.jpg",
        VipsIntOption("access", VipsRaw.VIPS_ACCESS_SEQUENTIAL())
    )
    val sourceWidth = VipsImage.Xsize(sourceImage)
    val sourceHeight = VipsImage.Ysize(sourceImage)
    logger.info("source image size: $sourceWidth x $sourceHeight")

    val outputPath = workingDirectory.resolve("rabbit_copy.jpg")
    vips.imageWriteToFile(sourceImage, outputPath.absolutePathString())

    val outputImagePointer = VipsOutputPointer(arena)
    vips.thumbnail("sample/src/main/resources/sample_images/rabbit.jpg", outputImagePointer, 400)
    val thumbnailImage = outputImagePointer.dereferencedOrThrow()
    val thumbnailPath = workingDirectory.resolve("rabbit_thumbnail_400.jpg")
    vips.imageWriteToFile(thumbnailImage, thumbnailPath.absolutePathString())

    val thumbnailWidth = VipsImage.Xsize(thumbnailImage)
    val thumbnailHeight = VipsImage.Ysize(thumbnailImage)
    logger.info("thumbnail image size: $thumbnailWidth x $thumbnailHeight")
}
```

The project has several samples, [described below](#samples).

## Project goals

Ideas and suggestions are welcome, but please make sure they fit in to these goals, or you have a good argument about
why a goal should change!

* Avoid manual work by automating as much as possible. This means upstream changes can be rapidly integrated.
* Keep generated APIs as similar to the original as is sensible. Small changes to make the API nicer, or make correct 
  usage easier, are ok (eg `gboolean` -> `boolean`, or `VipsOutputPointer` to manage tricky pointer translations).
* Provide access to the raw bindings (`VipsRaw`), so users aren't blocked by helper bugs or API annoyances.
* Incubate in [Photo Fox](https://github.com/lopcode/photo-fox) with some "real world" usage.

## Samples

Samples are included that show various usages of the `libvips` bindings. They include validations, and run on GitHub
Actions as "end-to-end tests" during development.

To get set up to run samples (on macOS):
* `brew install vips`
* `sdk use java 22-open`
* `./setup_lib_symlinks.sh`
* (Optional, to regenerate bindings) `./generate_ffm_bindings.sh`
* Then either:
  * Run `./run_samples.sh` in your terminal
  * Run `SampleRunner` in IntelliJ to run samples and validations

```
[main] INFO vipsffm.SampleRunner - clearing sample run directory at path "sample_run"
[main] INFO vipsffm.SampleRunner - running sample "RawGetVersionSample"...
[main] INFO vipsffm.RawGetVersionSample - libvips version: "8.15.2"
[main] INFO vipsffm.SampleRunner - validation succeeded ✅
[main] INFO vipsffm.SampleRunner - running sample "HelperGetVersionSample"...
[main] INFO vipsffm.HelperGetVersionSample - libvips version: "8.15.2"
[main] INFO vipsffm.SampleRunner - validation succeeded ✅
[main] INFO vipsffm.SampleRunner - running sample "RawCreateThumbnailSample"...
[main] INFO vipsffm.RawGetVersionSample - source image size: 2490 x 3084
[main] INFO vipsffm.RawGetVersionSample - output image size: 323 x 400
[main] INFO vipsffm.SampleRunner - validation succeeded ✅
[main] INFO vipsffm.SampleRunner - running sample "HelperCreateThumbnailSample"...
[main] INFO vipsffm.RawGetVersionSample - source image size: 2490 x 3084
[main] INFO vipsffm.RawGetVersionSample - thumbnail image size: 323 x 400
[main] INFO vipsffm.SampleRunner - validation succeeded ✅
[main] INFO vipsffm.SampleRunner - shutting down vips to check for memory leaks...
memory: high-water mark 36.55 MB
[main] INFO vipsffm.SampleRunner - all samples ran successfully 🎉
```

[1]: https://docs.oracle.com/en/java/javase/22/core/memory-segments-and-arenas.html